<!DOCTYPE html>
<!--
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/base/iteration_helpers.html">

<script>
'use strict';

tr.exportTo('tr.model', function() {
  var ClockDomainId = {
    BATTOR: 'BATTOR',

    // NOTE: Exists for backwards compatibility with old Chrome traces which
    // didn't explicitly specify the clock being used.
    UNKNOWN_CHROME_LEGACY: 'UNKNOWN_CHROME_LEGACY',

    LINUX_CLOCK_MONOTONIC: 'LINUX_CLOCK_MONOTONIC',
    MAC_MACH_ABSOLUTE_TIME: 'MAC_MACH_ABSOLUTE_TIME',
    WIN_ROLLOVER_PROTECTED_TIME_GET_TIME:
        'WIN_ROLLOVER_PROTECTED_TIME_GET_TIME',
    WIN_QPC: 'WIN_QPC'
  };

  var CHROME_CLOCK_DOMAINS = new Set([
    ClockDomainId.LINUX_CLOCK_MONOTONIC,
    ClockDomainId.MAC_MACH_ABSOLUTE_TIME,
    ClockDomainId.WIN_ROLLOVER_PROTECTED_TIME_GET_TIME,
    ClockDomainId.WIN_QPC
  ]);

  /**
   * Returns a function that, given a timestamp in fromMarker's domain, returns
   * a timestamp in toMarker's domain.timestamps in fromMarker's domain into
   * timestamps in toMarker's domain.
   */
  function createTransformer(fromMarker, toMarker) {
    var fromTs = fromMarker.ts, toTs = toMarker.ts;

    // TODO(charliea): Usually, we estimate that the clock sync marker is
    // issued by the agent exactly in the middle of the controller's start and
    // end timestamps. However, there's currently a bug in the Chrome serial
    // code that's making the clock sync ack for BattOr take much longer to
    // read than it should (by about 8ms). This is causing the above estimate
    // of the controller's sync timestamp to be off by a substantial enough
    // amount that it makes traces hard to read. For now, make an exception
    // for BattOr and just use the controller's start timestamp as the sync
    // time. In the medium term, we should fix the Chrome serial code in order
    // to remove this special logic and get an even more accurate estimate.
    if (fromMarker.domainId == ClockDomainId.BATTOR &&
        toMarker.duration > BATTOR_FAST_SYNC_THRESHOLD_MS) {
      toTs = toMarker.startTs;
    } else if (toMarker.domainId == ClockDomainId.BATTOR &&
        fromMarker.duration > BATTOR_FAST_SYNC_THRESHOLD_MS) {
      fromTs = fromMarker.startTs;
    }

    var tsShift = toTs - fromTs;
    return (ts) => { return ts + tsShift; };
  }

  /**
   * Given two transformers, creates a third that's a composition of the two.
   *
   * @param{function(Number): Number} toCurrentDomainTransformer A function
   *     capable of converting a timestamp from some original domain into a
   *     timestamp in the current domain.
   * @param{function(Number): Number} toNextDomainTransformer A function capable
   *     of converting a timestamp from the current domain into a timestamp in
   *     the next domain.
   *
   * @returns{function(Number): Number} A function capable of converting a
   *     timestamp from some original domain into a timestamp in the next
   *     domain.
   */
  function composeTransformers(
      toCurrentDomainTransformer, toNextDomainTransformer) {
    return function(ts) {
      return toNextDomainTransformer(toCurrentDomainTransformer(ts));
    };
  }

  // The number of milliseconds above which the BattOr sync is no longer
  // considered "fast", and it's more accurate to use the sync start timestamp
  // instead of the normal sync timestamp due to a bug in the Chrome serial code
  // making serial reads too slow.
  var BATTOR_FAST_SYNC_THRESHOLD_MS = 3;

  /**
   * A ClockSyncManager holds clock sync markers and uses them to shift
   * timestamps from agents' clock domains onto the model's clock domain.
   *
   * In this context, a "clock domain" is a single perspective on the passage
   * of time. A single computer can have multiple clock domains because it
   * can have multiple methods of retrieving a timestamp (e.g.
   * clock_gettime(CLOCK_MONOTONIC) and clock_gettime(CLOCK_REALTIME) on Linux).
   * Another common reason for multiple clock domains within a single trace
   * is that traces can span devices (e.g. a laptop collecting a Chrome trace
   * can have its power consumption recorded by a second device and the two
   * traces can be viewed alongside each other).
   *
   * For more information on how to synchronize multiple time domains using this
   * method, see: http://bit.ly/1OVkqju.
   *
   * @constructor
   */
  function ClockSyncManager() {
    // A set of all domains seen by the ClockSyncManager.
    this.domainsSeen_ = new Set();

    // TODO(charliea): Convert this to an ES6 map
    this.markersBySyncId_ = {};

    // TODO(charliea): Convert this to a ES6 map
    // transformerMapByDomainId_[fromDomain][toDomain] returns the function
    // that, given a timestamp in fromDomain, returns that timestamp in
    // toDomain.
    this.transformerMapByDomainId_ = {};
  }

  ClockSyncManager.prototype = {
    /**
     * Adds a clock sync marker to the list of known markers.
     *
     * @param {string} domainId The clock domain that the marker is in.
     * @param {string} syncId The identifier shared by both sides of the clock
     *                 sync marker.
     * @param {number} startTs The time (in ms) at which the sync started.
     * @param {number=} opt_endTs The time (in ms) at which the sync ended. If
     *                 unspecified, it's assumed to be the same as the start,
     *                 indicating an instantaneous sync.
     */
    addClockSyncMarker: function(domainId, syncId, startTs, opt_endTs) {
      this.domainsSeen_.add(domainId);

      if (tr.b.dictionaryValues(ClockDomainId).indexOf(domainId) < 0) {
        throw new Error('"' + domainId + '" is not in the list of known ' +
            'clock domain IDs.');
      }

      if (this.modelDomainId_ !== undefined) {
        throw new Error('Cannot add new clock sync markers after getting ' +
            'a model time transformer.');
      }

      var marker = new ClockSyncMarker(domainId, startTs, opt_endTs);

      if (this.markersBySyncId_[syncId] === undefined) {
        this.markersBySyncId_[syncId] = [marker];
        return;
      }

      var markers = this.markersBySyncId_[syncId];

      if (markers.length === 2) {
        throw new Error('Clock sync with ID "' + syncId + '" is already ' +
            'complete - cannot add a third clock sync marker to it.');
      }

      if (markers[0].domainId === domainId) {
        throw new Error('A clock domain cannot sync with itself.');
      }

      // TODO(charliea): Get rid of this restriction and instead choose the path
      // between the two clock domains with the least potential error.
      if (this.getTransformerBetween_(markers[0].domainId, domainId)) {
        throw new Error('Cannot add multiple paths between the same clock ' +
            'domains.');
      }

      markers.push(marker);

      this.getOrCreateTransformerMap_(markers[0].domainId)[domainId] =
          createTransformer(markers[0], marker);
      this.getOrCreateTransformerMap_(domainId)[markers[0].domainId] =
          createTransformer(marker, markers[0]);
    },

    /**
     * Returns a function that, given a timestamp in the specified clock domain,
     * returns a timestamp in the model's clock domain.
     *
     * NOTE: All clock sync markers should be added before calling this function
     * for the first time. This is because the first time that this function is
     * called, a model clock domain is selected. This clock domain must have
     * syncs connecting it with all other clock domains. If multiple clock
     * domains are viable candidates, the one with the clock domain ID that is
     * the first alphabetically is selected.
     */
    getModelTimeTransformer: function(domainId) {
      this.domainsSeen_.add(domainId);
      this.ensureLegacyTransformersExist_();

      // TODO(charliea): If domainId is a Chrome one, then create clock sync
      // markers to the other chrome domains.
      if (this.modelDomainId_ === undefined)
        this.selectModelDomainId_(domainId);

      var transformer =
          this.getTransformerBetween_(domainId, this.modelDomainId_);
      if (transformer === undefined) {
        throw new Error('No clock sync markers exist pairing clock domain "' +
            domainId + '" ' + 'with model clock domain "' +
            this.modelDomainId_ + '".');
      }

      return transformer;
    },

    // Returns a function that, given a timestamp in |fromDomainId|, returns a
    // timestamp in |toDomainId|.
    getTransformerBetween_: function(fromDomainId, toDomainId) {
      if (fromDomainId === toDomainId)
        return tr.b.identity;

      var visitedDomainById = {};

      var toVisit = [];
      toVisit.push({ domainId: fromDomainId, transformer: tr.b.identity });

      while (toVisit.length > 0) {
        var current = toVisit.shift();

        if (visitedDomainById[current.domainId])
          continue;
        visitedDomainById[current.domainId] = true;

        if (current.domainId === toDomainId)
          return current.transformer;

        var outgoingTransformers =
            this.transformerMapByDomainId_[current.domainId];

        if (outgoingTransformers === undefined)
          continue;

        for (var outgoingDomainId in outgoingTransformers) {
          var toNextDomainTransformer = outgoingTransformers[outgoingDomainId];
          var toCurrentDomainTransformer = current.transformer;

          toVisit.push({
            domainId: outgoingDomainId,
            transformer: composeTransformers(
                toNextDomainTransformer, toCurrentDomainTransformer)
          });
        }
      }

      return undefined;
    },

    /**
     * Ensures that identity transformers exist UNKNOWN_LEGACY_CHROME and all
     * other Chrome clock domains. This solves the problem where domain A is
     * connected to UNKNOWN_CHROME_LEGACY, domain B is connected to
     * LINUX_CLOCK_MONOTONIC, and domains A and B should be connected, but they
     * aren't because the ClockSyncManager doesn't recognize that
     * UNKNOWN_CHROME_LEGACY and LINUX_CLOCK_MONOTONIC are in fact the same
     * clock domain.
     */
    ensureLegacyTransformersExist_: function() {
      if (this.domainsSeen_.has(ClockDomainId.UNKNOWN_CHROME_LEGACY)) {
        for (var domainId of CHROME_CLOCK_DOMAINS) {
          if (this.domainsSeen_.has(domainId)) {
            this.collapseDomains_(
                ClockDomainId.UNKNOWN_CHROME_LEGACY, domainId);
          }
        }
      }
    },

    selectModelDomainId_: function(requestedTransformerDomainId) {
      if (tr.b.dictionaryLength(this.markersBySyncId_) === 0) {
        this.modelDomainId_ = requestedTransformerDomainId;
        return true;
      }

      if (!this.allDomainsAreConnected_()) {
        throw new Error('Unable to select a master clock domain because no ' +
            'clock domain is directly connected to all others.');
      }

      var uniqueDomainIds = this.uniqueDomainIds_();
      uniqueDomainIds.sort();
      this.modelDomainId_ = uniqueDomainIds[0];
    },

    getOrCreateTransformerMap_: function(domainId) {
      if (this.transformerMapByDomainId_[domainId] === undefined)
        this.transformerMapByDomainId_[domainId] = {};

      return this.transformerMapByDomainId_[domainId];
    },

    collapseDomains_: function(domain1Id, domain2Id) {
      addClockSyncMarker(domain1Id, domain1Id + '_TO_' + domain2Id, 0);
      addClockSyncMarker(domain2Id, domain1Id + '_TO_' + domain2Id, 0);
    },

    /** Returns true when all domains with registered markers are connected. */
    allDomainsAreConnected_: function() {
      var uniqueDomainIds = this.uniqueDomainIds_();

      // NOTE: this is a ridiculously inefficient way to do this. Given how few
      // clock domains we're likely to have, this shouldn't be a problem.
      for (var i = 1; i < uniqueDomainIds.length; i++) {
        if (this.getTransformerBetween_(
            uniqueDomainIds[0], uniqueDomainIds[i]) === undefined) {
          return false;
        }
      }

      return true;
    },

    uniqueDomainIds_: function() {
      var uniqueDomainIds = {};

      for (var syncId in this.markersBySyncId_) {
        var marks = this.markersBySyncId_[syncId];
        for (var i = 0; i < marks.length; i++) {
          uniqueDomainIds[marks[i].domainId] = true;
        }
      }

      return Object.keys(uniqueDomainIds);
    }
  };

  /**
   * A ClockSyncMarker is an internal entity that represents a marker in a
   * trace log indicating that a clock sync happened at a specified time.
   *
   * If no end timestamp argument is specified in the constructor, it's assumed
   * that the end timestamp is the same as the start (i.e. the clock sync
   * was instantaneous).
   */
  function ClockSyncMarker(domainId, startTs, opt_endTs) {
    this.domainId = domainId;
    this.startTs = startTs;
    this.endTs = opt_endTs === undefined ? startTs : opt_endTs;
  }

  ClockSyncMarker.prototype = {
    get duration() { return this.endTs - this.startTs; },
    get ts() { return this.startTs + this.duration / 2; }
  };

  return {
    ClockDomainId: ClockDomainId,
    ClockSyncManager: ClockSyncManager
  };
});
</script>

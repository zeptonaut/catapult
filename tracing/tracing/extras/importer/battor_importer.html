<!DOCTYPE html>
<!--
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/importer/importer.html">
<link rel="import" href="/tracing/model/model.html">
<link rel="import" href="/tracing/model/power_series.html">

<script>
/**
 * @fileoverview Imports text files in the BattOr format into the
 * Model. This format is output by the battor_agent executable and library.
 *
 * This importer assumes the events arrive as a string. The unit tests provide
 * examples of the trace format.
 */
'use strict';

tr.exportTo('tr.e.importer.battor', function() {
  /**
   * Imports a BattOr power trace into a specified model.
   * @constructor
   */
  function BattorImporter(model, events) {
    this.importPriority = 3; // runs after the linux_perf importer
    this.sampleRate_ = undefined;
    this.model_ = model;
    this.lines_ = events.split('\n');
  }

  var TestExports = {};

  var battorDataLineRE = new RegExp(
      '^(\\d+\\.\\d+)\\s+(\\d+\\.\\d+)\\s+(\\d+\\.\\d+)' +
      '(?:\\s+<(\\S+)>)?$'
  );
  var battorHeaderLineRE = /^# BattOr/;
  var sampleRateLineRE = /^# sample_rate (\d+) Hz/;

  /**
   * Guesses whether the provided events is a BattOr string.
   * Looks for the magic string "# BattOr" at the start of the file,
   *
   * @return {boolean} True when events is a BattOr array.
   */
  BattorImporter.canImport = function(events) {
    if (!(typeof(events) === 'string' || events instanceof String))
      return false;

    return battorHeaderLineRE.test(events);
  };

  BattorImporter.prototype = {
    __proto__: tr.importer.Importer.prototype,

    get importerName() {
      return 'BattorImporter';
    },

    get model() {
      return this.model_;
    },

    /**
     * Imports clock sync markers in this.events_ into model_.
     */
    importClockSyncMarkers: function() {
      for (var line of this.lines_) {
        var groups = battorDataLineRE.exec(line);
        if (!groups)
          continue;

        var ts = parseFloat(groups[1]);
        var syncId = groups[4];

        if (syncId) {
          this.model_.clockSyncManager.addClockSyncMarker(
              tr.model.ClockDomainId.BATTOR, syncId, ts);
        }
      }
    },

    /**
     * Imports the data in this.events_ into model_.
     */
    importEvents: function() {
      // Fail if the model already has a Power counter.
      if (this.model_.device.powerSeries) {
        this.model_.importWarning({
          type: 'import_error',
          message: 'Power counter exists, can not import BattOr power trace.'
        });
        return;
      }

      // Create series and import power samples into it.
      var series = new tr.model.PowerSeries(this.model_.device);
      this.importPowerSamples(series);

      this.model_.device.powerSeries = series;
    },

    /**
     * Walks the events and populates a time series with power samples.
     */
    importPowerSamples: function(series) {
      var modelTimeTransformer =
          this.model_.clockSyncManager.getModelTimeTransformer(
            tr.model.ClockDomainId.BATTOR);

      this.lines_.forEach(function(line) {
        line = line.trim();
        if (line.length === 0)
          return;

        if (/^#/.test(line)) {
          // Parse sample rate.
          groups = sampleRateLineRE.exec(line);
          if (!groups)
            return;
          this.sampleRate_ = parseInt(groups[1]);
        } else {
          // Parse power sample.
          var groups = battorDataLineRE.exec(line);
          if (!groups) {
            this.model_.importWarning({
              type: 'parse_error',
              message: 'Unrecognized line: ' + line
            });
            return;
          }

          // Add power sample.
          var ts = parseFloat(groups[1]);
          var voltage_V = parseFloat(groups[2]) / 1000;
          var current_A = parseFloat(groups[3]) / 1000;

          // Create power sample and convert to internal power units (Watts).
          var power_W = voltage_V * current_A;
          series.addPowerSample(modelTimeTransformer(ts), power_W);
        }
      }, this);
    }
  };

  tr.importer.Importer.register(BattorImporter);

  return {
    BattorImporter: BattorImporter,
    _BattorImporterTestExports: TestExports
  };
});

</script>

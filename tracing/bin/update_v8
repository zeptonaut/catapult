#!/usr/bin/env python
# Copyright 2015 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""Updates the 64 bit d8 binary for the specified target OS to match the v8
version used in the current version of the specified Chromium channel.

Currently, we can only update the d8 binary for the operating system that we're
building on.

This script assumes that git is installed and the computer meets all
other prerequisites to build v8 normally (like having depot_tools installed and
in the path).

Example usage:
$ tracing/bin/update_v8 linux stable
"""

import json
import os
import shutil
import subprocess
import sys
import tempfile
import urllib2

OMAHAPROXY_VERSION_MAP_URL = 'https://omahaproxy.appspot.com/all.json'

V8_PATH = os.path.join('third_party', 'vinn', 'third_party', 'v8')
# The target OS goes in this path, so we leave a hook for it.
V8_BINARY_PATH = os.path.join(V8_PATH, '{0}', 'x86_64', 'd8')
V8_README_PATH = os.path.join(V8_PATH, 'README.chromium')

V8_CHECKOUT_BINARY_PATH = os.path.join('v8', 'out', 'Release', 'd8')
V8_GENERATE_GYP_CMD = '{0} -Dtarget_arch=x64'.format(os.path.join('build', 'gyp_v8'))
V8_COMPILE_CMD = 'ninja -C {0} d8'.format(os.path.join('out', 'Release'))

VALID_OS_LIST = ['linux', 'mac', 'win']
VALID_CHANNEL_LIST = ['stable', 'canary', 'beta', 'dev']

def Main(args):

  if len(args) != 2:
    print('Usage: update_v8 <target_os> <target_channel>')
    return 1

  target_os = args[0]
  target_channel = args[1]

  if target_os not in VALID_OS_LIST:
    print('Invalid target OS. Valid: {0}'.format(VALID_OS_LIST))
    return 1

  if target_channel not in VALID_CHANNEL_LIST:
    print('Invalid target channel. Valid: {0}'.format(VALID_CHANNEL_LIST))
    return 1

  # Fetch the current version map from omahaproxy.
  response = urllib2.urlopen(OMAHAPROXY_VERSION_MAP_URL)
  versions = json.loads(response.read())

  # Find the v8 version that corresponds to the current target OS and target
  # channel.
  v8_version = None
  for curr_os in versions:
    for curr_version in curr_os['versions']:
      if (curr_version['os'] == target_os and
          curr_version['channel'] == target_channel):
        v8_version = curr_version['v8_version']

  # Clone v8, checkout the version that corresponds to our target OS and target
  # channel, and build the d8 binary.
  with tmpdir() as v8_checkout_path:
    with cd(v8_checkout_path):
      subprocess.check_call('fetch v8', shell=True)
      with cd('v8'):
        subprocess.check_call('git checkout {0}'.format(v8_version), shell=True)

        os.environ['GYP_GENERATORS'] = 'ninja'
        subprocess.check_call(V8_GENERATE_GYP_CMD, shell=True)
        subprocess.check_call(V8_COMPILE_CMD, shell=True)

    # Move the d8 binary into place.
    project_root_path = os.path.join(os.path.dirname(__file__),
                                     os.path.pardir,
                                     os.path.pardir)
    d8_src = os.path.join(v8_checkout_path, V8_CHECKOUT_BINARY_PATH)
    d8_dst = os.path.join(project_root_path, V8_BINARY_PATH.format(target_os))

    shutil.move(d8_src, d8_dst)

    # Update the v8 version number in its README.chromium file.
    # TODO: Do this replacement with python replace API
    # sed_cmd = 's/\([0-9\.]*\) ({0})/{1} ({0})/g'.format(target_os, v8_version)
    # full_sed_cmd = 'sed -i "" "{0}" {1}/README.chromium'.format(sed_cmd, V8_PATH)
    #
    # subprocess.check_call(full_sed_cmd, shell=True)

  return 0

class cd:
  """A context manager that changes a directory while in scope."""
  def __init__(self, newPath):
    self.newPath = newPath

  def __enter__(self):
    self.oldPath = os.getcwd()
    os.chdir(self.newPath)

  def __exit__(self, etype, value, traceback):
    os.chdir(self.oldPath)

class tmpdir:
  """A context manager that creates a temporary directory while in scope."""
  def __enter__(self):
    self.path = tempfile.mkdtemp()
    print "creating {0}".format(self.path)
    return self.path

  def __exit__(self, etype, value, traceback):
    shutil.rmtree(self.path)

if __name__ == '__main__':
  sys.exit(Main(sys.argv[1:]))


<!DOCTYPE html>
<!--
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/base/iteration_helpers.html">
<link rel="import" href="/tracing/model/event_set.html">
<link rel="import" href="/tracing/ui/analysis/alert_sub_view.html">
<link rel="import" href="/tracing/ui/analysis/analysis_sub_view.html">
<link rel="import"
    href="/tracing/ui/analysis/container_memory_dump_sub_view.html">
<link rel="import" href="/tracing/ui/analysis/counter_sample_sub_view.html">
<link rel="import" href="/tracing/ui/analysis/layout_tree_sub_view.html">
<link rel="import" href="/tracing/ui/analysis/multi_async_slice_sub_view.html">
<link rel="import" href="/tracing/ui/analysis/multi_cpu_slice_sub_view.html">
<link rel="import" href="/tracing/ui/analysis/multi_flow_event_sub_view.html">
<link rel="import" href="/tracing/ui/analysis/multi_frame_sub_view.html">
<link rel="import"
      href="/tracing/ui/analysis/multi_instant_event_sub_view.html">
<link rel="import" href="/tracing/ui/analysis/multi_object_sub_view.html">
<link rel="import" href="/tracing/ui/analysis/multi_power_sample_sub_view.html">
<link rel="import" href="/tracing/ui/analysis/multi_sample_sub_view.html">
<link rel="import" href="/tracing/ui/analysis/multi_thread_slice_sub_view.html">
<link rel="import"
      href="/tracing/ui/analysis/multi_thread_time_slice_sub_view.html">
<link rel="import"
    href="/tracing/ui/analysis/multi_user_expectation_sub_view.html">
<link rel="import" href="/tracing/ui/analysis/single_async_slice_sub_view.html">
<link rel="import" href="/tracing/ui/analysis/single_cpu_slice_sub_view.html">
<link rel="import" href="/tracing/ui/analysis/single_flow_event_sub_view.html">
<link rel="import" href="/tracing/ui/analysis/single_frame_sub_view.html">
<link rel="import"
      href="/tracing/ui/analysis/single_instant_event_sub_view.html">
<link rel="import"
      href="/tracing/ui/analysis/single_object_instance_sub_view.html">
<link rel="import"
      href="/tracing/ui/analysis/single_object_snapshot_sub_view.html">
<link rel="import"
      href="/tracing/ui/analysis/single_power_sample_sub_view.html">
<link rel="import" href="/tracing/ui/analysis/single_sample_sub_view.html">
<link rel="import"
      href="/tracing/ui/analysis/single_thread_slice_sub_view.html">
<link rel="import"
      href="/tracing/ui/analysis/single_thread_time_slice_sub_view.html">
<link rel="import"
    href="/tracing/ui/analysis/single_user_expectation_sub_view.html">
<link rel="import" href="/tracing/ui/base/tab_view2.html">

<!--
@fileoverview A component used to display an analysis of a selection,
using custom elements specialized for different event types.
-->
<dom-module id='tr-ui-a-analysis-view'>
  <template>
    <style>
      :host {
        background-color: white;
        display: flex;
        flex-direction: column;
        height: 275px;
        overflow: auto;
      }

      :host(.tall-mode) {
        height: 525px;
      }

      ::content > * {
        flex: 1 0 auto;
      }
    </style>
    <content></content>
  </template>
</dom-module>
<script>
'use strict';
(function() {
  var EventRegistry = tr.model.EventRegistry;

  Polymer({
    is: 'tr-ui-a-analysis-view',

    ready: function() {
      this.tabView_ = document.createElement('tr-ui-a-tab-view2');
      this.tabView_.addEventListener(
          'selected-tab-change', onSelectedTabChanged_);

      Polymer.dom(this).appendChild(this.tabView_);
      this.brushingStateController_ = undefined;
      this.onSelectedTabChange_ = this.onSelectedTabChange_.bind(this);
      this.onSelectionChanged_ = this.onSelectionChanged_.bind(this);

      this.lastSeenSelection_ = new tr.model.EventSet();
    },

    set tallMode(value) {
      if (value)
        Polymer.dom(this).classList.add('tall-mode');
      else
        Polymer.dom(this).classList.remove('tall-mode');
    },

    get tallMode() {
      return Polymer.dom(this).classList.contains('tall-mode');
    },

    get tabView() {
      return this.tabView_;
    },

    get brushingStateController() {
      return this.brushingStateController_;
    },

    set brushingStateController(brushingStateController) {
      if (this.brushingStateController) {
        this.brushingStateController_.removeEventListener(
            'change', this.onSelectionChanged_);
      }
      this.brushingStateController_ = brushingStateController;
      if (this.brushingStateController) {
        this.brushingStateController_.addEventListener(
            'change', this.onSelectionChanged_);
      }
      this.onSelectionChanged_();
    },

    get selection() {
      return this.brushingStateController_.selection;
    },

    onSelectionChanged_: function(e) {
      var selection = this.brushingStateController_.selection;

      if (this.lastSeenSelection_.equals(selection))
        return;
      this.lastSeenSelection_ = selection;

      this.tallMode = false;
      while (Polymer.dom(this.tabView).children.length) {
        Polymer.dom(this.tabView).removeChild(
            Polymer.dom(this.tabView.firstChild));
      }

      if (!selection.length)
        this.tabView.label = 'Nothing selected. Tap stuff.';
      else if (selection.length === 1)
        this.tabView.label = '1 item selected.';
      else
        this.tabView.label = selection.length + ' items selected.';

      var eventsByBaseTypeName = selection.getEventsOrganizedByBaseType(true);
      for (var eventTypeName in eventsByBaseTypeName) {
        var subView = this.createSubViewForSelection_(
            eventTypeName, eventsByBaseTypeName[eventTypeName]);
        Polymer.dom(this.tabView_).appendChild(subView);
      }

      this.tabView_.addEventListener(
        'selected-tab-change', this.onSelectedTabChange_);
    },

    createSubViewForSelection_: function(eventTypeName, subSelection) {
      var eventTypeInfo =
          EventRegistry.getEventTypeInfoByTypeName(eventTypeName);
      var tagName = subSelection.length === 1 ?
          eventTypeInfo.metadata.singleViewElementName :
          eventTypeInfo.metadata.multiViewElementName;

      var subView = document.createElement(tagName);
      // Unregistered elements with valid names (i.e. names that have a hyphen
      // in them) that are instantiated inherit from HTMLElement. Unregistered
      // elements with invalid names inherit from HTMLUnknownelement.
      if (subView.constructor === HTMLElement ||
          subView.constructor === HTMLUnknownElement)
        throw new Error('Element not registered: ' + tagName);

      subView.tabLabel = getLabelForSelection_(eventTypeName, subSelection);
      subView.selection = subSelection;
      return subView;
    },

    getLabelForSelection_: function(eventTypeName, subSelection) {
      var camelLabel = subSelection.length === 1 ?
          EventRegistry.getUserFriendlySingularName(eventTypeName) :
          EventRegistry.getUserFriendlyPluralName(eventTypeName);
      return camelLabel + ' (' + subSelection.length + ')';
    },

    onSelectedTabChanged_: function() {
      var brushingStateController = this.brushingStateController_;
      if (this.tabView_.selectedTab) {
        var selectedTab = this.tabView_.selectedTab;
        this.tallMode = selectedTab.requiresTallView;
        if (brushingStateController) {
          var rlth = selectedTab.relatedEventsToHighlight;
          brushingStateController.changeAnalysisViewRelatedEvents(rlth);
        }
      } else {
        this.tallMode = false;
        if (brushingStateController)
          brushingStateController.changeAnalysisViewRelatedEvents(undefined);
      }
    }
  });
})();
</script>

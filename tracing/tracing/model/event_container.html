<!DOCTYPE html>
<!--
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/base/base.html">
<link rel="import" href="/tracing/base/guid.html">
<link rel="import" href="/tracing/base/range.html">

<script>
'use strict';

tr.exportTo('tr.model', function() {

  /**
   * EventContainer is a base class for any class in the trace model that
   * contains child events or child EventContainers.
   *
   * For all EventContainers, updateBounds() must be called after modifying the
   * container's events if an up-to-date bounds is expected.
   *
   * @constructor
   */
  function EventContainer() {
    this.guid_ = tr.b.GUID.allocateSimple();
    this.important = true;
    this.bounds_ = new tr.b.Range();
  }

  EventContainer.prototype = {
    get guid() {
      return this.guid_;
    },

    /**
     * @return {String} A stable and unique identifier that describes this
     * container's position in the event tree relative to the root. If an event
     * container 'B' is a child to another event container 'A', then container
     * B's stable ID would be 'A.B'.
     */
    get stableId() {
      throw new Error('Not implemented');
    },

    /**
     * Returns the bounds of the event container, which describe the range
     * of timestamps for all ancestor events.
     */
    get bounds() {
      return this.bounds_;
    },

    // TODO(charliea): A default implementation of this method could likely be
    // provided that uses 'iterateAllEvents'.
    /**
     * Updates the bounds of the event container. After updating, this.bounds
     * will describe the range of timestamps of all ancestor events.
     */
    updateBounds: function() {
      throw new Error('Not implemented');
    },

    // TODO(charliea): A default implementation of this method could likely be
    // provided that uses 'iterateAllEvents'.
    /**
     * Shifts the timestamps for ancestor events by 'amount' milliseconds.
     */
    shiftTimestampsForward: function(amount) {
      throw new Error('Not implemented');
    },

    /**
     * Iterates over all child events.
     */
    iterateAllEventsInThisContainer: function(eventTypePredicate,
                                              callback, opt_this) {
      // TODO(alexandermont): We need this.childEvents() to take an
      // eventTypePredicate because it doesn't look possible to directly get the
      // type object from an object, so we have to do the filtering before
      // the iteration. Probably it would be better if we find a workaround
      // for this.
      for (var event of this.childEvents(eventTypePredicate, opt_this))
        callback.call(opt_this, event);
    },

    /**
     * Iterates over all child containers.
     */
    iterateAllChildEventContainers: function(callback, opt_this) {
      for (var container of this.childEventContainers())
        callback.call(opt_this, container);
    },

    /**
     * Iterates over all events in this container and in descendant
     * event containers.
     */
    iterateAllEvents: function(callback, opt_this) {
      // If new-style iteration has been implemented for this container, use
      // it for iterateAllEvents.
      if (this.childEvents && this.childEventContainers) {
        for (var event of this.childEvents(x => true, opt_this))
          callback.call(opt_this, event);
        for (var container of this.childEventContainers())
          container.iterateAllEvents(callback, opt_this);
      } else {
        // Otherwise, just do it the old way.
        this.iterateAllEventContainers(function(ec) {
          ec.iterateAllEventsInThisContainer(x => true, callback, opt_this);
        });
      }
    },

    /**
     * Iterates over this container and all descendant containers.
     */
    iterateAllEventContainers: function(callback, opt_this) {
      // If new-style iteration has been implemented for this container, use
      // it for iterateAllEventContainers.
      if (this.childEvents && this.childEventContainers) {
        callback.call(opt_this, this);
        for (var container of this.childEventContainers())
          container.iterateAllEventContainers(callback, opt_this);
      } else {
        // Otherwise, just do it the old way.
        function visit(ec) {
          callback.call(opt_this, ec);
          ec.iterateAllChildEventContainers(visit);
        }
        visit(this);
      }
    },

    /**
     * Finds topmost slices in this container (see docstring for
     * findTopmostSlices).
     */
    findTopmostSlicesInThisContainer: function(eventPredicate, callback,
                                               opt_this) {
      throw new Error('Not implemented.');
    },

    /**
     * The findTopmostSlices* series of helpers find all topmost slices
     * satisfying the given predicates.
     *
     * As an example, suppose we are trying to find slices named 'C', with the
     * following thread:
     *
     *  -> |---C---| |-----D-----|
     *       |-C-|      |---C---| <-
     *
     * findTopmostSlices would locate the pointed-to Cs, because the bottom C on
     * the  left is not the topmost C, and the right one is, even though it is
     * not itself a top-level slice.
     */
    findTopmostSlices: function(eventPredicate, callback, opt_this) {
      this.iterateAllEventContainers(function(ec) {
        ec.findTopmostSlicesInThisContainer(eventPredicate, callback, opt_this);
      });
    },

    findTopmostSlicesNamed: function(name, callback, opt_this) {
      this.findTopmostSlices(e => e.title === name, callback, opt_this);
    }
  };

  return {
    EventContainer: EventContainer
  };
});
</script>
